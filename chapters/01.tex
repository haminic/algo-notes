\chapter{Divide-and-Conquer}

\section{ปัญหา Maximum Subarray}

สมมติเรามีลำดับของจำนวนจริง (array) ชุดหนึ่ง และเราต้องการหาลำดับย่อยที่เรียงติดกันที่มีผลรวมมากที่สุด (จะเรียกว่าเป็น \emph{maximum subarray}) เราอาจจะทำตรง ๆ เลยโดยเช็คทุก ๆ ลำดับย่อยที่เป็นไปได้ซึ่งถ้าลำดับนี้มีจำนวนสมาชิกอยู่ $n$ ตัว จะทำให้ต้องเช็คลำดับย่อยทั้งหมด $\binom{n}{2}$ ชุด จึงต้องใช้เวลา $\Omega(n^2)$

อีกวิธีที่ดีกว่าคือการใช้ recursion โดยเราจะแบ่ง array ที่ได้รับมานี้ออกเป็น 2 subarray (โดยจะเก็บ index ไว้สามตัวคือ $\var{low}$, $\var{mid}$, และ $\var{high}$) ไปเรื่อย ๆ และหา maximum subarray ของ subarray ซ้าย, subarray ขวา, และ maximum subarray ที่ข้ามจุดแบ่ง (crossing subarray) จากนั้นเลือกค่าที่มากที่สุดในสามกรณีนี้

สังเกตว่าเราสามารถหา maximum crossing subarray ของ array $A$ ขนาด $n$ ที่ผ่าน $\var{mid}$ ได้โดยการหา maximum subarray ของครึ่งซ้ายรวมกับของครึ่งขวา:
\begin{codebox}{การหา Maximum Crossing Subarray}
    \defvar{vsum}{sum}
    \defvar{vlsum}{leftSum}
    \defvar{vrsum}{rightSum}
    \defvar{vlow}{low}
    \defvar{vmid}{mid}
    \defvar{vhigh}{high}

    \Fn{$\func{findMaxCrossingSubarray}{A, \vlow, \vmid, \vhigh}$}{
        $\vlsum$ \gets $-\infty$\;
        $\vsum$ \gets $0$\;
        \For{$i$ \gets $\vmid$ \Downto $\vlow$}{
            $\vsum$ \gets $\vsum + A[i]$\;
            \If{$\vsum > \vlsum$}{
                $\vlsum$ \gets $\vsum$\;
                $\var{maxLeft}$ \gets $i$
            }
        }
        do similarly for the right, i.e., find maximum $\var{rightSum}$ and $\var{maxRight}$ index\;
        \Ret{$\tuple{\var{maxLeft}, \var{maxRight}, \vlsum + \vrsum}$}
    }
\end{codebox}
ซึ่งใช้เวลา $\Theta(n)$

ดังนั้นก็จะได้อัลกอริทึมในการหา maximum subarray โดยการ \emph{divide-and-conquer}:
\begin{codebox}{อัลกอริทึม Maximum Subarray}
    \Fn{$\func{findMaxSubarray}{A, \var{low}, \var{high}}$}{
        \If{$\var{low} = \var{high}$}{
            \Ret $\tuple{\var{low}, \var{high}, A[\var{low}]}$
        }
        $\var{mid}$ \gets $\floor{(\var{low} + \var{high})/2}$\;
        $(\var{left}_i)_{i=1}^3$ \gets $\func{findMaxSubarray}{A, \var{low}, \var{mid}}$\;
        $(\var{mid}_i)_{i=1}^3$ \gets $\func{findMaxCrossingSubarray}{A, \var{low}, \var{mid}, \var{high}}$\;
        $(\var{right}_i)_{i=1}^3$ \gets $\func{findMaxSubarray}{A, \var{mid} + 1, \var{high}}$\;
        $\var{maxSubarray}$ \gets choose $x\in\{\var{left},\var{mid},\var{right}\}$ with maximum $x_3$\;
        \Ret $\var{maxSubarray}$
    }
\end{codebox}
โดยเราจะเรียก $\func{findMaxSubarray}{A, 1, A.\var{length}}$ เมื่อต้องการหา maximum subarray ของ $A$ 

ถ้ากำหนดให้อัลกอริทึมนี้ทำงานได้ในเวลา $T(n)$ ก็จะได้ความสัมพันธ์
\begin{eqnobox}
    T(n) = 2T(\floor{n/2}) + \Theta(n)
\end{eqnobox}
(เพราะการหา $\var{left}$ และ $\var{right}$ เป็นการเรียกฟังก์ชันเดิมนี้ซ้ำ โดยที่ array มีขนาดลดลงครึ่งหนึ่ง ใช้เวลา $T(\floor{n/2})$, การหา $\var{mid}$ ใช้เวลา $\Theta(n)$, และที่เหลือทั้งหมดใช้เวลา $\Theta(1)$) โดยในส่วนถัด ๆ ไปเราจะแก้ได้ว่าความสัมพันธ์เวียนเกิดนี้มีคำตอบ $T(n) = \Theta(n\lg n)$ ซึ่งเร็วกว่าการทำตรง ๆ

\section{อัลกอริทึมการคูณเมทริกซ์ของ Strassen}

\section{ความสัมพันธ์เวียนเกิด}